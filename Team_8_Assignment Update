{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#These are the libraries you can use.  You may add any libraries directy related to threading if this is a direction\n",
    "#you wish to go (this is not from the course, so it's entirely on you if you wish to use threading).  Any\n",
    "#further libraries you wish to use you must email me, james@uwaterloo.ca, for permission.\n",
    "\n",
    "from IPython.display import display, Math, Latex\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import numpy_financial as npf\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "import random\n",
    "import threading\n",
    "\n",
    "from datetime import datetime"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Group Assignment\n",
    "### Team Number: 08\n",
    "### Team Member Names: Richard Meng, Avaansh Nanda, Devesh Kotak\n",
    "### Team Strategy Chosen: Market Beat"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We first start by reading the CSV file of tickers and processing the tickers as a list for easy iteration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['AAPL',\n",
       " 'ABBV',\n",
       " 'ABT',\n",
       " 'ACN',\n",
       " 'AGN',\n",
       " 'AIG',\n",
       " 'AMZN',\n",
       " 'AXP',\n",
       " 'BA',\n",
       " 'BAC',\n",
       " 'BB.TO',\n",
       " 'BIIB',\n",
       " 'BK',\n",
       " 'BLK',\n",
       " 'BMY',\n",
       " 'C',\n",
       " 'CAT',\n",
       " 'CELG',\n",
       " 'CL',\n",
       " 'KO',\n",
       " 'LLY',\n",
       " 'LMT',\n",
       " 'MO',\n",
       " 'MON',\n",
       " 'MRK',\n",
       " 'PEP',\n",
       " 'PFE',\n",
       " 'PG',\n",
       " 'PM',\n",
       " 'PYPL',\n",
       " 'QCOM',\n",
       " 'RTN',\n",
       " 'RY.TO',\n",
       " 'SHOP.TO',\n",
       " 'T.TO',\n",
       " 'TD.TO',\n",
       " 'TXN',\n",
       " 'UNH',\n",
       " 'UNP',\n",
       " 'UPS',\n",
       " 'USB']"
      ]
     },
     "execution_count": 140,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# read in the csv file and set the header to none, otherwise it will treat the first ticker as the header\n",
    "tickers_csv = pd.read_csv(\"Tickers_Example.csv\", header=None)\n",
    "# turn the csv dataframe into a list\n",
    "tickers = list(tickers_csv[0])\n",
    "tickers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Below are some helper functions to help assist filtering our stock data using data threading. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#  We will be filtering 40 tickers. Each thread will handle 5 tickers which download from yfinance simultaneously, speeding up the process.\n",
    "START_DATE = \"2024-10-01\"\n",
    "END_DATE = \"2025-09-30\"\n",
    "\n",
    "# helper function to download stock data for a subset of tickers, index is between (0, number_of_threads-1)\n",
    "def download_yf(ticker_subset, result_df, index):\n",
    "    data = {}\n",
    "    # looping through each ticker and downloading the data from yfinance, and storing in \n",
    "    for ticker in ticker_subset:\n",
    "        data[ticker] = yf.download(ticker, START_DATE, END_DATE)\n",
    "    result_df[index] = data \n",
    "    return result_df # returning the dataframe with updated values \n",
    "\n",
    "# helper function to create & start a thread to download 5 tickers' stock data from yfinance\n",
    "def start_threading(five_tickers_array):\n",
    "    # creating 8 threads in the for loop\n",
    "    threading.Thread(target=download_yf, args=(five_tickers_array)).start()\n",
    "\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we begin filtering the stocks. We first must check that they are Canadian or American, which can be done by checking their currency. Then we check if the company is actually listed on its respective market. Lastly, we check the daily average volume (excluding months with less than 18 trading days) and exclude stocks with less than 5000 daily average volume."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "AAPL\n",
      "ABBV\n",
      "ABT\n",
      "ACN\n",
      "AGN\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "1 Failed download:\n",
      "['AGN']: YFTzMissingError('possibly delisted; no timezone found')\n",
      "$AGN: possibly delisted; no price data found  (period=5d) (Yahoo error = \"No data found, symbol may be delisted\")\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "AGN is delisted\n",
      "AIG\n",
      "AMZN\n",
      "AXP\n",
      "BA\n",
      "BAC\n",
      "BB.TO\n",
      "BIIB\n",
      "BK\n",
      "BLK\n",
      "BMY\n",
      "C\n",
      "CAT\n",
      "CELG\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "1 Failed download:\n",
      "['CELG']: YFTzMissingError('possibly delisted; no timezone found')\n",
      "$CELG: possibly delisted; no price data found  (period=5d) (Yahoo error = \"No data found, symbol may be delisted\")\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CELG is delisted\n",
      "CL\n",
      "KO\n",
      "LLY\n",
      "LMT\n",
      "MO\n",
      "MON\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "1 Failed download:\n",
      "['MON']: YFTzMissingError('possibly delisted; no timezone found')\n",
      "$MON: possibly delisted; no price data found  (period=5d) (Yahoo error = \"No data found, symbol may be delisted\")\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MON is delisted\n",
      "MRK\n",
      "PEP\n",
      "PFE\n",
      "PG\n",
      "PM\n",
      "PYPL\n",
      "QCOM\n",
      "RTN\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "1 Failed download:\n",
      "['RTN']: YFTzMissingError('possibly delisted; no timezone found')\n",
      "$RTN: possibly delisted; no price data found  (period=5d) (Yahoo error = \"No data found, symbol may be delisted\")\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "RTN is delisted\n",
      "RY.TO\n",
      "SHOP.TO\n",
      "T.TO\n",
      "TD.TO\n",
      "TXN\n",
      "UNH\n",
      "UNP\n",
      "UPS\n",
      "USB\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "{'AAPL': ('Technology', 'USD'),\n",
       " 'ABBV': ('Healthcare', 'USD'),\n",
       " 'ABT': ('Healthcare', 'USD'),\n",
       " 'ACN': ('Technology', 'USD'),\n",
       " 'AIG': ('Financial Services', 'USD'),\n",
       " 'AMZN': ('Consumer Cyclical', 'USD'),\n",
       " 'AXP': ('Financial Services', 'USD'),\n",
       " 'BA': ('Industrials', 'USD'),\n",
       " 'BAC': ('Financial Services', 'USD'),\n",
       " 'BB.TO': ('Technology', 'CAD'),\n",
       " 'BIIB': ('Healthcare', 'USD'),\n",
       " 'BK': ('Financial Services', 'USD'),\n",
       " 'BLK': ('Financial Services', 'USD'),\n",
       " 'BMY': ('Healthcare', 'USD'),\n",
       " 'C': ('Financial Services', 'USD'),\n",
       " 'CAT': ('Industrials', 'USD'),\n",
       " 'CL': ('Consumer Defensive', 'USD'),\n",
       " 'KO': ('Consumer Defensive', 'USD'),\n",
       " 'LLY': ('Healthcare', 'USD'),\n",
       " 'LMT': ('Industrials', 'USD'),\n",
       " 'MO': ('Consumer Defensive', 'USD'),\n",
       " 'MRK': ('Healthcare', 'USD'),\n",
       " 'PEP': ('Consumer Defensive', 'USD'),\n",
       " 'PFE': ('Healthcare', 'USD'),\n",
       " 'PG': ('Consumer Defensive', 'USD'),\n",
       " 'PM': ('Consumer Defensive', 'USD'),\n",
       " 'PYPL': ('Financial Services', 'USD'),\n",
       " 'QCOM': ('Technology', 'USD'),\n",
       " 'RY.TO': ('Financial Services', 'CAD'),\n",
       " 'SHOP.TO': ('Technology', 'CAD'),\n",
       " 'T.TO': ('Communication Services', 'CAD'),\n",
       " 'TD.TO': ('Financial Services', 'CAD'),\n",
       " 'TXN': ('Technology', 'USD'),\n",
       " 'UNH': ('Healthcare', 'USD'),\n",
       " 'UNP': ('Industrials', 'USD'),\n",
       " 'UPS': ('Industrials', 'USD'),\n",
       " 'USB': ('Financial Services', 'USD')}"
      ]
     },
     "execution_count": 153,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# IMPORTANT: FIND OUT HOW TO USE THREADING TO MAKE THIS PROCESS AS FAST AS POSSIBLE\n",
    "\n",
    "# initialize limits/constants\n",
    "valid_currencies = [\"CAD\",\"USD\"]\n",
    "min_volume = 5000\n",
    "min_trading_days = 18\n",
    "start_date = \"2024-10-01\"\n",
    "end_date = \"2025-09-30\"\n",
    "def filter_tickers(tickers):\n",
    "    # keep track of a boolean to see if we are below minimum volume\n",
    "    below_min_vol = False\n",
    "    # store valid_tickers as a dictionary to store along with their respective sector to deal with the sector percentage rule\n",
    "    valid_tickers={}\n",
    "    # loop through each ticker in ticker\n",
    "    for ticker in tickers:\n",
    "        print(ticker)\n",
    "        # use try and except to prevent delisting errors stopping our code\n",
    "        try:\n",
    "            # store the ticker as a yf.Ticker to find info on currency and sector\n",
    "            yfTicker = yf.Ticker(ticker)\n",
    "            # store data to get trading volume + loop through the dates to find number of trading days per month\n",
    "            ticker_data = yf.download(ticker, start=start_date, end=end_date, auto_adjust=False, progress=False)\n",
    "            # store the currency\n",
    "            currency = yfTicker.fast_info['currency']\n",
    "            # store the sector\n",
    "            sector = yfTicker.info['sector']\n",
    "            # create a date range with the start of each month in range\n",
    "            month_starts = pd.date_range(start=start_date, end=end_date, freq=\"MS\")\n",
    "            # create a date range with the end of each month in rage\n",
    "            month_ends = pd.date_range(start=start_date, end=end_date, freq=\"ME\")\n",
    "            # initialize current month index to 0 and num trading days equal to 0\n",
    "            cur_month_idx = 0\n",
    "            num_trading_days = 0\n",
    "            # keep track of the tickers total volume and number of total trading days to find avg daily volume\n",
    "            total_vol = 0\n",
    "            total_trading_days = 0\n",
    "            # initialize date index\n",
    "            date_idx = 0\n",
    "            dates = ticker_data.index\n",
    "            # loop through each date in the ticker data\n",
    "            while date_idx < len(dates) and cur_month_idx < len(month_starts):\n",
    "                date = dates[date_idx]\n",
    "               # if the date is less than the end date of current month it is in\n",
    "                if date <= month_ends[cur_month_idx]:\n",
    "                    # first add one to the number of trading days\n",
    "                    num_trading_days += 1\n",
    "                    total_trading_days += 1\n",
    "                    # if it is greater than 18, now we check the daily average volume\n",
    "                    #    if its less than 5000 don't add this stock to valid stocks.\n",
    "                    # otherwise, if the number of trading days isn't greater than 18\n",
    "                    #    continue on as then we'll exclude it or wait until it goes above 18\n",
    "                    if num_trading_days >= min_trading_days:\n",
    "                        ticker_month_data = yf.download(ticker, start=month_starts[cur_month_idx], end=month_ends[cur_month_idx], auto_adjust=False, progress=False)\n",
    "                        total_vol += ticker_month_data[\"Volume\"].sum().iloc[0]\n",
    "                        date_idx = np.searchsorted(dates, month_ends[cur_month_idx])\n",
    "\n",
    "                # now we have surpassed the month end and will go to the next month       \n",
    "                else:\n",
    "                    cur_month_idx += 1\n",
    "                    num_trading_days = 0\n",
    "\n",
    "                date_idx+=1\n",
    "            # calculate average daily volume\n",
    "            avg_daily_vol = total_vol/total_trading_days\n",
    "            # if the average daily volume is less than the minimum or the currency is invalid, don't add the ticker.\n",
    "            if avg_daily_vol<min_volume or not(currency in valid_currencies):\n",
    "                continue\n",
    "            # otherwise, if it's valid, then add the key pair ticker, (sector, currency) to valid_tickers for easy access to a ticker's info.\n",
    "            else:\n",
    "                valid_tickers[ticker] = (sector,currency)\n",
    "        # the except will catch delisted stocks and exclude them from valid_tickers\n",
    "        except Exception as e:\n",
    "            print(f\"{ticker} is delisted\")\n",
    "\n",
    "    return valid_tickers\n",
    "\n",
    "\n",
    "filter_tickers(tickers)\n",
    "    \n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Contribution Declaration\n",
    "\n",
    "The following team members made a meaningful contribution to this assignment:\n",
    "\n",
    "Insert Names Here.\n",
    "- Richard Meng\n",
    "- Avaansh Nanda\n",
    "- Devesh Kotak"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
